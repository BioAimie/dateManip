{
    "collab_server" : "",
    "contents" : "#' Return the mean and limits for the sparse data frame, allowing for alternate limits and one sided or two sided limits.\n#'\n#' This function takes a data frame outputted from the mergeCalSparseFrames function and paritions the data frame by the rateParitionVec parameter. It then finds the mean and limits, and colors data points accordingly.\n#'\n#' @param sparseRateFrame a sparse data frame created using the \\code{mergeCalSparseFrames} function\n#' @param ratePartitionVec a character string vector that specifies how to parition the categories in the data frame\n#' @param ignorePeriods a numeric, default of 0, that indicates how many periods from the current DateGroup to neglect in calculating the average and standard deviation\n#' @param returnLimits a logical with default FALSE that specifies whether or not the data frame returned should have limits\n#' @param limitFactor a numeric, default of 3, that specifies the number of standard deviations from the mean to set the limit\n#' @param limitSide a character string, default of upper, that indicates whether the limit should be +X from the mean (upper), -X from the mean (lower), or +/-X from the mean (two.sided)\n#' @param altUL a numeric, default of 0.001, that indicates a default limit if the altUL > limitFactor*sd(X)\n#' @param altLL a numeric, default of 0, that indicates a default limit if the altLL < limitFactor*sd(X)\n#' @return a data frame that contains the orginal columns in sparseRateFrame, as well as an average for each of the ratePartitionVec combinations. It may also have limits if limit parameters are specified.\n#' @author Aimie Faucett\n#' @details\n#' This function takes in a sparseRateFrame that is made using the \\code{mergeCalSparseFrames} function and return the mean for each unique combination of\n#' the entries in the ratePartitionVec. If the limit parameters are entered, the Rate variable is colored as 'pass' or 'review' based on limitFactor*sd(X)\n#' and that value is either added, subtracted, or added and subtracted to make a range about the mean where the data set falls in or out of teh limits. The\n#' altUL and altLL allow the user to specify an alternate limit that can be applied instead of the limitFactor.\n#' @export\n\naddStatsToSparseHandledData <- function(sparseRateFrame, ratePartitionVec, ignorePeriods = 0, returnLimits = FALSE, limitFactor = 3, limitSide = 'upper', altUL = 0.001, altLL = 0.00) {\n\n  if(length(ratePartitionVec) == 1) {\n\n    sparseRateFrame[,'combocat'] <- sparseRateFrame[,ratePartitionVec]\n  } else {\n\n    sparseRateFrame[,'combocat'] <- do.call(paste, c(sparseRateFrame[,ratePartitionVec], sep=','))\n  }\n\n  comboCats <- as.character(unique(sparseRateFrame[,'combocat']))\n  avgFrame <- as.data.frame(do.call(rbind, lapply(1:length(comboCats), function(x) cbind(combocat = comboCats[x], Avg = mean(sparseRateFrame[sparseRateFrame[,'combocat'] == comboCats[x], 'Rate'][1:(length(sparseRateFrame[sparseRateFrame[,'combocat'] == comboCats[x],'DateGroup']) - ignorePeriods)], na.rm=TRUE)))))\n  sparseRateFrame <- merge(sparseRateFrame, avgFrame, by='combocat')\n\n  if(returnLimits == FALSE) {\n\n    return(sparseRateFrame)\n  } else {\n\n    sdFrame <- as.data.frame(do.call(rbind, lapply(1:length(comboCats), function(x) cbind(combocat = comboCats[x], Sdev = sd(sparseRateFrame[sparseRateFrame[,'combocat'] == comboCats[x], 'Rate'][1:(length(sparseRateFrame[sparseRateFrame[,'combocat'] == comboCats[x],'DateGroup']) - ignorePeriods)], na.rm=TRUE)))))\n    sparseRateFrame <- merge(sparseRateFrame, sdFrame, by='combocat')\n\n    if(limitSide == 'upper') {\n\n      maxFrame <- as.data.frame(cbind(combocat = comboCats, Max = sapply(1:length(comboCats), function(x) ifelse(max(sparseRateFrame[sparseRateFrame[,'combocat'] == comboCats[x], 'Rate'], na.rm=TRUE) > altUL, max(sparseRateFrame[sparseRateFrame[,'combocat'] == comboCats[x], 'Rate'], na.rm=TRUE), altUL))))\n      sparseRateFrame <- merge(sparseRateFrame, maxFrame, by='combocat')\n      sparseRateFrame[,'Avg'] <- as.numeric(as.character(sparseRateFrame[,'Avg']))\n      sparseRateFrame[,'Sdev'] <- as.numeric(as.character(sparseRateFrame[,'Sdev']))\n      sparseRateFrame[,'Max'] <- as.numeric(as.character(sparseRateFrame[,'Max']))\n      sparseRateFrame[,'UL'] <- sparseRateFrame[,'Avg'] + limitFactor*sparseRateFrame[,'Sdev']\n      sparseRateFrame[,'Color'] <- with(sparseRateFrame, ifelse(Rate > UL, 'review','pass'))\n      keepCols <- colnames(sparseRateFrame)[!(colnames(sparseRateFrame) %in% colnames(sparseRateFrame)[grep('combocat|Max', colnames(sparseRateFrame))])]\n\n      return(sparseRateFrame[,keepCols])\n    } else if(limitSide == 'lower') {\n\n      minFrame <- as.data.frame(cbind(combocat = comboCats, Min = sapply(1:length(comboCats), function(x) ifelse(min(sparseRateFrame[sparseRateFrame[,'combocat'] == comboCats[x], 'Rate'], na.rm=TRUE) < altLL, min(sparseRateFrame[sparseRateFrame[,'combocat'] == comboCats[x], 'Rate'], na.rm=TRUE), altLL))))\n      sparseRateFrame <- merge(sparseRateFrame, minFrame, by='combocat')\n      sparseRateFrame[,'Avg'] <- as.numeric(as.character(sparseRateFrame[,'Avg']))\n      sparseRateFrame[,'Sdev'] <- as.numeric(as.character(sparseRateFrame[,'Sdev']))\n      sparseRateFrame[,'Min'] <- as.numeric(as.character(sparseRateFrame[,'Min']))\n      sparseRateFrame[,'LL'] <- sparseRateFrame[,'Avg'] - limitFactor*sparseRateFrame[,'Sdev']\n      sparseRateFrame[,'Color'] <- with(sparseRateFrame, ifelse(Rate < LL, 'review','pass'))\n      keepCols <- colnames(sparseRateFrame)[!(colnames(sparseRateFrame) %in% colnames(sparseRateFrame)[grep('combocat|Min', colnames(sparseRateFrame))])]\n\n      return(sparseRateFrame[,keepCols])\n    } else if(limitSide == 'two.sided') {\n\n      minFrame <- as.data.frame(cbind(combocat = comboCats, Min = sapply(1:length(comboCats), function(x) ifelse(min(sparseRateFrame[sparseRateFrame[,'combocat'] == comboCats[x], 'Rate'], na.rm=TRUE) < altLL, min(sparseRateFrame[sparseRateFrame[,'combocat'] == comboCats[x], 'Rate'], na.rm=TRUE), altLL))))\n      maxFrame <- as.data.frame(cbind(combocat = comboCats, Max = sapply(1:length(comboCats), function(x) ifelse(max(sparseRateFrame[sparseRateFrame[,'combocat'] == comboCats[x], 'Rate'], na.rm=TRUE) > altUL, max(sparseRateFrame[sparseRateFrame[,'combocat'] == comboCats[x], 'Rate'], na.rm=TRUE), altUL))))\n      sparseRateFrame <- merge(sparseRateFrame, minFrame, by='combocat')\n      sparseRateFrame <- merge(sparseRateFrame, maxFrame, by='combocat')\n      sparseRateFrame[,'Avg'] <- as.numeric(as.character(sparseRateFrame[,'Avg']))\n      sparseRateFrame[,'Sdev'] <- as.numeric(as.character(sparseRateFrame[,'Sdev']))\n      sparseRateFrame[,'Min'] <- as.numeric(as.character(sparseRateFrame[,'Min']))\n      sparseRateFrame[,'Max'] <- as.numeric(as.character(sparseRateFrame[,'Max']))\n      sparseRateFrame[,'LL'] <- sparseRateFrame[,'Avg'] - limitFactor*sparseRateFrame[,'Sdev']\n      sparseRateFrame[,'UL'] <- sparseRateFrame[,'Avg'] + limitFactor*sparseRateFrame[,'Sdev']\n      sparseRateFrame[,'Color'] <- with(sparseRateFrame, ifelse(Rate < LL | Rate > UL, 'review','pass'))\n      keepCols <- colnames(sparseRateFrame)[!(colnames(sparseRateFrame) %in% colnames(sparseRateFrame)[grep('combocat|Max|Min', colnames(sparseRateFrame))])]\n\n      return(sparseRateFrame[,keepCols])\n    } else {\n\n      stop(\"The limitSide parameter has been specified incorrectly... the function take three options: 'upper', 'lower', or 'two.sided'.\")\n    }\n  }\n}\n",
    "created" : 1465412420320.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "2247238206",
    "id" : "C9A41507",
    "lastKnownWriteTime" : 1465486340,
    "last_content_update" : 1465486340347,
    "path" : "~/dateManip/R/addStatsToSparseHandledData.R",
    "project_path" : "R/addStatsToSparseHandledData.R",
    "properties" : {
        "tempName" : "Untitled1"
    },
    "relative_order" : 5,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}